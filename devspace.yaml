version: v1beta11

# `vars` specifies variables which may be used as ${VAR_NAME} in devspace.yaml
vars:
  - name: DOCKER_USERNAME
    value: pacor2010

images:
  auth:
    image: ${DOCKER_USERNAME}/auth
    dockerfile: auth/Dockerfile
    context: ./auth
    tags: [latest]
    # build:
    #   docker:
    #     preferMinikube: true
    #     skipPush: true
  client:
    image: ${DOCKER_USERNAME}/client
    dockerfile: client/Dockerfile
    context: ./auth
    tags: [latest]
    # build:
    #   docker:
    #     preferMinikube: true
    #     skipPush: true
  expiration:
    image: ${DOCKER_USERNAME}/expiration
    dockerfile: expiration/Dockerfile
    context: ./expiration
    tags: [latest]
    # build:
    #   docker:
    #     preferMinikube: true
    #     skipPush: true
  orders:
    image: ${DOCKER_USERNAME}/orders
    dockerfile: orders/Dockerfile
    context: ./orders
    tags: [latest]
    # build:
    #   docker:
    #     preferMinikube: true
    #     skipPush: true
  payments:
    image: ${DOCKER_USERNAME}/payments
    dockerfile: payments/Dockerfile
    context: ./payments
    tags: [latest]
    # build:
    #   docker:
    #     preferMinikube: true
    #     skipPush: true
  tickets:
    image: ${DOCKER_USERNAME}/tickets
    dockerfile: tickets/Dockerfile
    context: ./tickets
    tags: [latest]
    # build:
    #   docker:
    #     preferMinikube: true
    #     skipPush: true

# `deployments` tells DevSpace how to deploy this project
deployments:
  - name: ticketing
    # This deployment uses `kubectl` but you can also define `helm` deployments
    kubectl:
      manifests:
        - infra/k8s
        - infra/k8s-dev

# `dev` only applies when you run `devspace dev`
dev:
  # # `dev.ports` specifies all ports that should be forwarded while `devspace dev` is running
  # # Port-forwarding lets you access your application via localhost on your local machine
  # ports:
  #   - imageSelector: ${DOCKER_USERNAME}/client
  #     forward:
  #       - port: 3000

  # # `dev.open` tells DevSpace to open certain URLs as soon as they return HTTP status 200
  # # Since we configured port-forwarding, we can use a localhost address here to access our application
  # # open:
  #   - url: http://localhost:3000

  # # `dev.sync` configures a file sync between our Pods in k8s and your local project files
  # sync:
  #   - imageSelector: ${DOCKER_USERNAME}/auth
  #     localSubPath: ./auth
  #     containerPath: /app
  #     # excludeFile: node_modules
  #   - imageSelector: ${DOCKER_USERNAME}/client
  #     localSubPath: ./client
  #     containerPath: /app
  #     # excludeFile: node_modules
  #   - imageSelector: ${DOCKER_USERNAME}/expiration
  #     localSubPath: ./expiration
  #     containerPath: /app
  #     # excludeFile: node_modules
  #   - imageSelector: ${DOCKER_USERNAME}/orders
  #     localSubPath: ./orders
  #     containerPath: /app
  #     # excludeFile: node_modules
  #   - imageSelector: ${DOCKER_USERNAME}/payments
  #     localSubPath: ./payments
  #     containerPath: /app
  #     # excludeFile: node_modules
  #   - imageSelector: ${DOCKER_USERNAME}/tickets
  #     localSubPath: ./tickets
  #     containerPath: /app
  #     # excludeFile: node_modules

  # `dev.terminal` tells DevSpace to open a terminal as a last step during `devspace dev`
  terminal:
    imageSelector: ${DOCKER_USERNAME}/client
    # With this optional `command` we can tell DevSpace to run a script when opening the terminal
    # This is often useful to display help info for new users or perform initial tasks (e.g. installing dependencies)
    # DevSpace has generated an example ./devspace_start.sh file in your local project - Feel free to customize it!
    command:
      - ./devspace_start.sh

  # # Since our Helm charts and manifests deployments are often optimized for production,
  # # DevSpace let's you swap out Pods dynamically to get a better dev environment
  # replacePods:
  #   - imageSelector: ${DOCKER_USERNAME}/client
  #     # Since the `${IMAGE}` used to start our main application pod may be distroless or not have any dev tooling, let's replace it with a dev-optimized image
  #     # DevSpace provides a sample image here but you can use any image for your specific needs
  #     replaceImage: loftsh/alpine:latest
  #     # Besides replacing the container image, let's also apply some patches to the `spec` of our Pod
  #     # We are overwriting `command` + `args` for the first container in our selected Pod, so it starts with `sleep 9999999`
  #     # Using `sleep 9999999` as PID 1 (instead of the regular ENTRYPOINT), allows you to start the application manually
  #     patches:
  #       - op: replace
  #         path: spec.containers[0].command
  #         value:
  #           - sleep
  #       - op: replace
  #         path: spec.containers[0].args
  #         value:
  #           - "9999999"
  #       - op: remove
  #         path: spec.containers[0].securityContext

# `profiles` lets you modify the config above for different environments (e.g. dev vs production)
profiles:
  # This profile is called `production` and you can use it for example using: devspace deploy -p production
  # We generally recommend to use the base config without any profiles as optimized for development (e.g. image build+push is disabled)
  - name: production
    # This profile adds our image to the config so that DevSpace will build, tag and push our image before the deployment
    merge:
      images:
        client:
          image: ${DOCKER_USERNAME}/client
          dockerfile: client/Dockerfile.prod
          context: client/
    deployments:
      - name: ticketing
        kubectl:
          manifests:
            - infra/k8s
            - infra/k8s-prod
